错误处理函数；
#include <iostream>
#include <stdexcept>

[[noreturn]] void panic(const char* message) {
    std::cerr << "PANIC: " << message << std::endl;
    
    // 可以选择不同的终止方式
    // std::exit(EXIT_FAILURE);    // 正常清理
    // std::abort();               // 立即终止（产生core dump）
    // std::terminate();           // 调用terminate_handler
    
    // 或者抛出异常
    throw std::runtime_error(message);
    
    // 注意：代码永远不会执行到这里
}

void dangerousOperation(int value) {
    if (value > 100) {
        panic("Value too large!");
    }
    // 编译器知道如果value>100，这里不会执行
    std::cout << "Safe operation with: " << value << std::endl;
}

无限循环函数：
[[noreturn]] void eventLoop() {
    while (true) {
        // 处理事件
        // ...
    }
    // 不会退出循环，因此不会返回
}

[[noreturn]] void serverMain() {
    initializeServer();
    eventLoop();  // 进入无限循环
    // 永远不会执行清理代码
    cleanupServer();  // ❌ 死代码，永远不会执行
}

自定义宏：
#include <cassert>

// 自定义断言宏
[[noreturn]] void my_assert_fail(
    const char* expr, 
    const char* file, 
    int line,
    const char* function) {
    
    std::cerr << "Assertion failed: " << expr << "\n"
              << "File: " << file << "\n"
              << "Line: " << line << "\n"
              << "Function: " << function << std::endl;
    std::abort();
}

#define MY_ASSERT(expr) \
    ((expr) ? (void)0 : my_assert_fail(#expr, __FILE__, __LINE__, __func__))

void test(int* ptr) {
    MY_ASSERT(ptr != nullptr);
    // 编译器知道ptr不为null，可以优化掉空指针检查
    *ptr = 42;
}